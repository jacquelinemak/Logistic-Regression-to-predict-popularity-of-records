# Source of data and code: Dimitris Bertsimas @ MIT

MusicRecord<-read.csv(file.choose()) #load data

# -------------- explore the data ------------------
str(MusicRecord)
head(MusicRecord)

#use past songs to predict new songs
SongsTrain = MusicRecord %>% filter(year <= 2009)
SongsTest = MusicRecord %>% filter(year == 2010)

# we want to exclude some of the variables in our dataset from being used as independent variables 
# ("year", "songtitle", "artistname", "songID", and "artistID"). To do this, we can use the following trick. 
# First define a vector of variable names called nonvars - these are the variables that we won't use in our model.
#look at the physical features of the songs
#only want to use continuous variables
nonvars = c("year", "songtitle", "artistname", "songID", "artistID")

# To remove these variables from your training and testing sets:
SongsTrain = SongsTrain[ , !(names(SongsTrain) %in% nonvars) ]
SongsTest = SongsTest[ , !(names(SongsTest) %in% nonvars) ]


# build a logistic regression model to predict Top10 using the training data. 
# We can now use "." in place of enumerating all the remaining independent variables in the following way:
SongsLog1 = glm(Top10 ~ ., data=SongsTrain, family=binomial)

summary(SongsLog1)

# You can make predictions on the test set by using the command:
testPredict = predict(SongsLog1, newdata=SongsTest, type="response")

testPredict #this generates the prob for each song - for example, the first song is only 3% chance to hit top 10

write.csv(testPredict, "/Users/jacquelinemak/MMA /MMA 867 Predictive Modelling/Predicted Popularity of records.csv") 

hist(testPredict) #predicted probability using a histogram
#heavily skewed - the vast majority of the songs wont hit top 10, have low prob of hitting top 10
#the frequency seems to decrease, a smalll # of songs above 80%, that's something we might want to invest, songs above 80%

# To generate the ROC curve
install.packages("pROC")
library(pROC)
test_prob = predict(SongsLog1, newdata = SongsTest, type = "response")
test_roc = roc(SongsTest$Top10 ~ test_prob, plot = TRUE, print.auc = TRUE)
#AUC - 0.843 -> it's good but it does not mean its 84.3% accurate 
#you want AUC to be higher 
#this curve only depends on the model, not the threshold, generated by many different threshold from 0 to 1
#this is the mapping of the threshold
#the higher the AUC, the better the model.

# ------------ Improve the prediction performance of the model
MusicRecord<-read.csv(file.choose()) #load data

#----------------------------------
# Principal Component Analysis (PCA)
#----------------------------------


# we want to exclude some of the variables in our dataset from being used as independent variables 
# ("year", "songtitle", "artistname", "songID", and "artistID"). 

#only want to use continuous variables, hence removing the varibles below
#First need to define a vector of variable names called nonvars - these are the variables that we won't use in our model.
nonvars = c("year", "songtitle", "artistname", "songID", "artistID")

MusicRecord_numeric = MusicRecord[ , !(names(MusicRecord) %in% nonvars) ]
dim(MusicRecord_numeric) #34 variables

#looking at the correlation between the interaction variables and Top 10
library(corrplot)
corrplot.mixed(cor(MusicRecord_numeric[ , c(1:34)]), upper="ellipse") #looking at if any interaction variables are highly correlated - they are not
cor(MusicRecord_numeric)

#apply pca
pca_music = prcomp(MusicRecord_numeric, center = TRUE, scale. = TRUE)
summary(pca_music)

names(pca_music) # check what's in the results

pca_music$rotation
# Check the weights of all PC's
#PC2 is positively related with loudness, if loudness is high then PC2 is high

pca_music$x # Check the loadings of all samples (scores of each PCs)

var.Music<-pca_music$sdev^2
var_explained_music <- var.Music/sum(var.Music) #plot the relative ratio 

barplot(var_explained_music, main="Proportion of Variance Explained", xlab="Principal component")

# Choosing the number of components is somewhat subjective; there is a clear break after the 3rd principal component(s), so we can choose the first 3 components
# Because the first 3 components have much larger variances than the rest. By doing so, it is believed that the remaining components are somewhat similar and are likely to be statistical noise.

loadings_music<-data.frame(pca_music$x)

#Plot the first 2 PC's
plot(loadings_music$PC1,loadings_music$PC2) 

#Plot the first 3 PC's
library("scatterplot3d") 
scatterplot3d(loadings_music$PC1,loadings_music$PC2,loadings_music$PC3)

#---------------------------------- Predictive Modelling with PCA 

SongsTrain = MusicRecord %>% filter(year <= 2009)
SongsTest = MusicRecord %>% filter(year == 2010)

#Remove the nonvars from your training and testing sets:
SongsTrain = SongsTrain[ , !(names(SongsTrain) %in% nonvars) ]
SongsTest = SongsTest[ , !(names(SongsTest) %in% nonvars) ]

install.packages("pls")
library(pls)
set.seed(2)

pcr.Music.fit=pcr(Top10~.,data=SongsTrain, center = TRUE, scale=TRUE, validation="CV")
summary(pcr.Music.fit)

validationplot(pcr.Music.fit, val.type = "MSEP")

#build datasets with our new pca
training_set_pca = as.data.frame(predict(pcr.Music.fit, SongsTrain))

head(training_set_pca)

#Choose the first 8 components 
training_set_pca <- training_set_pca[,1:17]

#need to put back the dependent variable
training_set_pca$Top10 = SongsTrain$Top10

#let's fix the test set
test_set_pca = as.data.frame(predict(pcr.Music.fit, SongsTest))
test_set_pca <- test_set_pca[,1:17]
test_set_pca$Top10 = SongsTest$Top10

#Fitting logistic regression to the training set 
SongsLog2 = glm(Top10 ~ ., 
                family=binomial,
                data=training_set_pca)

summary(SongsLog2)

# You can make predictions on the test set by using the command:
testPredict2 = predict(SongsLog2, newdata=test_set_pca, type="response")

testPredict2 #this generates the prob for each song - for example, the first song is only 3.28% chance to hit top 10

hist(testPredict2)

# To generate the ROC curve
library(pROC)
test_prob = predict(SongsLog2, newdata = test_set_pca, type = "response")
test_roc = roc(SongsTest$Top10 ~ test_prob, plot = TRUE, print.auc = TRUE)
#AUC - 0.732

# ------- Perform variable selection + transforming predictors

MusicRecord<-read.csv(file.choose()) #load data

#explore the data
str(MusicRecord)

#looking at the distribution of all interaction variables to determine if any transformation is needed 
par(mfrow=c(3,3))
hist(MusicRecord$timesignature) #normal
hist(MusicRecord$timesignature_confidence) #skewed to the right
hist(MusicRecord$loudness) #skewed to the right
hist(MusicRecord$tempo) #normal
hist(MusicRecord$tempo_confidence) #skewed to the right
hist(MusicRecord$key) #normal
hist(MusicRecord$key_confidence) #normal
hist(MusicRecord$energy) #skewed to the right
hist(MusicRecord$pitch) #skewed to the left
hist(MusicRecord$timbre_0_max) #skewed to the right
hist(MusicRecord$timbre_10_max) #ok normal

#use past songs to predict new songs
SongsTrain = MusicRecord %>% filter(year <= 2009)
SongsTest = MusicRecord %>% filter(year == 2010)

#only want to use continuous variables
nonvars = c("year", "songtitle", "artistname", "songID", "artistID")

# To remove these variables from your training and testing sets:
SongsTrain = SongsTrain[ , !(names(SongsTrain) %in% nonvars) ]
SongsTest = SongsTest[ , !(names(SongsTest) %in% nonvars) ]

str(SongsTrain)

# build a logistic regression model to predict Top10 using the training data. 
#use all variables
SongsLog1 = glm(Top10 ~ ., data=SongsTrain, family=binomial)
summary(SongsLog1)

#choose some variables that are significant + interaction variables
SongsLog3 = glm(Top10 ~ timesignature_confidence+loudness+tempo_confidence+tempo_confidence*energy+tempo_confidence*pitch+energy+pitch+timbre_0_min+timbre_0_max+timbre_1_min+timbre_3_max+timbre_4_min+timbre_4_max+timbre_5_min+timbre_6_min+timbre_10_max+timbre_11_min+timbre_11_max, data=SongsTrain, family=binomial)
summary(SongsLog3)

testPredict3 = predict(SongsLog3, newdata=SongsTest, type="response")
hist(testPredict3)

# To generate the ROC curve
library(pROC)
test_prob3 = predict(SongsLog3, newdata = SongsTest, type = "response")
test_roc3 = roc(SongsTest$Top10 ~ test_prob3, plot = TRUE, print.auc = TRUE)
